        +---------------------------+
		    | CS 140                    |
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	DESIGN DOCUMENT           |
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Alex Ryan <alexryan@stanford.edu>
Andy Moreland <andymo@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

Alex Ryan: everything
Andy Moreland: everything

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In thread.h's struct thread:

struct list pages_list;

`pages_list` is a list of pages spawned by the given thread. It's used
  during cleanup.

In page.c:



struct aux_pt_entry
{
  struct hash_elem elem; /* Hash table element */
  struct list_elem thread_pages_elem; /* Elem for a thread's page list */
  void *user_addr; /* User VADDR used as hash key */
  uint32_t *pd;    /* User pagedir */

  bool writable;       /* If the page if read-only */
  frame_id frame;      /* Casted pointer to the 
                          frame_table_entry for the
                          frame of the page if resident */
  
  ... // more, but described later in design doc.

};

This is the struct that we use in order to store information in our aux
page table about pages. Everything else is self-evident
in the comments I hope. The struct is dynamically allocated.

static struct hash aux_pt; /* The aux page table */
static struct lock aux_pt_lock; /* Lock for the aux page table -- 
                                   acquired before all operations on it. */

Just FYI we decided to call it the "aux" page table instead of the "suppl-
ementary" page table because it's easier to type :-).

In frame.h:

typedef void *frame_id;

we typedef'd void * to frame_id in order to hide the fact that the id
that we return to clients (namely page.c) from our API calls is actually
a void *.

In frame.c:

struct frame_table_entry
  {
    void *frame_addr; /* Kernel virtual address of frame. */
    void *user_addr;  /* User vaddr of page stored in frame. */
    uint32_t *pd;     /* User pd for page stored in frame. */
    struct lock pin_lock; /* Pin lock which is a monitor 
                             for resident page & this frame. */
    struct list_elem elem; /* elem for the frame table or free list. */
    bool is_dying;        /* If we are in the process of freeing this frame. */
  };

This struct is stored either in our frame_table list or in our free_list.
It stores everything we know about a given frame that is allocated. The
struct itself is dynamically allocated as necessary.

All of the attributes are commented.

/* Pointer to the "clock hand" position in the frame_table list. */
static struct frame_table_entry *clock_hand;
/* Allocated frames are stored in this list. */
static struct list frame_table;
/* Freed frames are stored in this list. */
static struct list free_list;
/* Protects the frame_table and the free_list */
static struct lock frame_table_lock;

The `frame_table_lock` is acquired before operations are done on the frame 
  table. Things like adding a new frame or evicting a frame require a
  brief acquisition of the frame_table_lock.

The `clock_hand` points to the current position of the clock hand that
  we need for our clock hand eviction algorithm.


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

The MMU uses the standard pagedir/page table system that was in place 
when we started writing code. We make sure to keep these tables up
to date as we create pages.

On the other hand, if we need to find the location of a frame for a
given page we do the following:

1) get the user vaddr of an address in the page
2) look up a aux_page_table_entry in a hash table in page.c
3) this entry contains an ID for (actually, an internal pointer to)
a frame_table_entry from frame.c 
4) the frame_table_entry contains a kernel address for the page's data.

A page retains the ID of its last resident frame if it has been paged
out; if it has been paged out, the frame can discern that it now 
contains the data for a different page.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We sidestep the issue by never touching memory through kernel addresses.
In theory the only time that user data should get dirty is if the user
themself touches it or uses a syscall. All of our syscalls directly
use user addresses.

Thus, the user page table entry is the only one that we need to check
for accessed and dirty bits.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

Before we do any operation on the frame table (eviction, creating new
frames, freeing a frame), we acquire a global lock.

palloc_get_page locks internally. Thus, if there are free frames in
the user pool, we're safe.

If there is nothing in the user pool, we check the free list next.
We make sure to acquire the frame table lock before iterating over the
free list, so there are no race conditions here.

On the other hand, if we need to perform an eviction we make sure
to acquire a lock on the frame table. This lock is held until
we find a frame which we're going to evict a page from.

Thus, in any situation where we need to acquire a page we hold a 
global lock until a slot is selected.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We chose to use a hash table from vaddrs to aux_ptes in order
to have O(1) lookup on a vaddr. This makes sense to do because the 
page fault handler only gets the vaddr when it's called, so we can't
do something like store a pointer directly to a struct.

Then, the aux_pte struct contains a direct reference to its frame or
eviction locations so looking up the actual physical address/file 
in which it lives is O(1).

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In swap.h:

typedef block_sector_t swap_descriptor;

We typedef block_sector_t so that our clients (namely page/frame.c) don't
  need to worry about how swap is laid out on disk. It represents the
  # of the first sector in a contiguous range of swap sectors.

In swap.c:

/* A bitmap that represents used swap sectors. */
static struct bitmap *swap_used_slots;

/* Lock to protect the aformentioned bitmap. */
static struct lock swap_used_slots_lock;

In page.c:

enum page_type
  {
    SWAP,
    SWAP_LAZY,
    MMAP
  }

This enum is used in order to track what eviction policy we pursue for
  a given page.

`SWAP` means that it is swapped in and out of swap on disk.
`SWAP_LAZY` means that at first it is paged in from a file, but if
  it gets dirty then we swap it out. For data segments, basically.
  Will change to `SWAP` if the page is ever dirty and evicted.
`MMAP` means that it's backed by a file and should be evicted to it
  and read in from it.

In page.c's `struct page`

  enum page_type type; /* Which eviction/backing policy to use */

  ...

  union { /* Either the info needed for mmap or swap */
    struct {
      size_t offset; /* How far into the file we are */
      size_t len; /* How much of the file to take */
      struct file *fd; /* Which file we're backed by */
    } mmap_info;

    swap_descriptor swap_info; /* Casted ID of the first swap sector */
  };

We store everything we need in order to to page in or evict here.
  Since any given page will only ever be stored in swap XOR
  backed by a file we store this data in a union to save a little
  memory.

`swap_descriptor` is a typecasted integer which represents the first
  sector in the swap space that stores this fram.

`mmap_info` stores information about where in the given file to look for
  reading this page back from -- or for writing it to.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We use a clock hand algorithm. We maintain a global "hand" pointer
which points to a frame_table_entry. The frame_table_entries
are stored in a list which we then iterate over while holding
a lock on the frame table.

At each entry we attempt to acquire a "pin" lock on the entry itself.
If we are able to acquire then pin lock then we know that no one else
is currently touching it. In this case, we check its accessed bit.
If it has not been accessed, we evict this frame and drop the
global lock. Otherwise, we clear its accessed bit and continue on.

(We loop at most twice through the entire frame table, so we could end
up evicting a frame that has been accessed recently. However, after
two attempts, if we still cannot pin anything, then everything is
pinned or highly active and we are unable to evict anything, so we panic.)

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

We have designed our code so that if we acquire a pin_lock on the frame
that we think we're resident in then we immediately check if we are 
actually still resident before doing any work. If we are resident,
then we own the frame. Otherwise, we've been paged out in the interim
and we immediately drop the lock.

This means that we don't need to have frames change their page's refs
to null. Instead, all that we do is ask the page to evict itself.

As part of this eviction, the page stores where it evicted itself to.
This can be a file or swap slot.

This also means that any page that has ever been resident ever has
some lock (the pin_lock of its last frame) that we are able to 
acquire in order to protect it.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

We check to see if the fault was caused by a user access. Then we check
the aux page table in order to make sure that there isn't supposed to be
memory mapped at that location.

Then, we check that the fault was either within 32 bytes of the esp or
that it was above the esp. If either of these conditions are true we
check to make sure that increasing the size of the stack further would
not exceed a maximum stack size of 8mb. If all of these conditions are
met then we grow the stack.

Note that this does allow holes (unmapped memory) in the stack. We feel
that allowing a sparse stack is a feature.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

The four conditions for deadlock are all of (1) limited access,
(2) no preemption, (3) multiple independent requests, and (4)
circularity in resources ownership requests. As in most systems,
the first three are unavoidable in our implementation, so we
chose to treat and prevent (4), although we do limit (3) when 
possible.

Our virtual memory implementation uses locks to prevent most of
the interesting concurrency problems: these locks are the
- fs_lock (file system)
- "data structure locks" (aux_page_table, frame_table, swap_used_slots)
- frame_pins (one for each frame)

All virtual memory calls acquire locks in the order
  (frame_table lock) 
    before (frame pins) 
    before (fs_lock | swap_used_slots lock)

(A corner case is when a frame is first created, in that it acquires 
the frame_table_lock before even creating the frame, but since the 
new frame isn't in the table, the lock cannot be held by another 
process yet.)

Furthermore, a process can pin as many of its *own* pages' frames
as it wants (and since we're single-threaded processes, cannot create
a race condition). However, a process can hold at most one of another
process's frames but _only when trying to evict it_ and is accomplished
through a try_acquire, avoiding any race conditions (it is impossible
for a process to be stuck waiting on another process's frame).

Finally, aux_page_table operations are all done either independently 
of any frame operations (i.e. when pages are first created, but have
not been given a resident frame) or while a page's own frame's pin
is held (so processes always acquire frame pins before aux_pt_lock).

One particularly notable cause of deadlock is that that comes from
syscalls page faulting. Since syscalls are executed while potentially
holding the file system lock if we page then our page fault handler
could try to evict some frame to swap. This would cause a deadlock
on ourself since we hold the device driver lock and are also trying
to acquire it. We avoid this by pre-emptively pinning every page
in any buffer that is read/written from in a syscall so as to
prevent page faults.


>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

Whenever a process P evicts another process Q's frame what we do is
acquire the pin lock on that frame and then immediately mark it as
not present in the page table.

Once these operations have been completed we start the eviction. If
an access from Q occurs at this point it will result in a page fault.
The page fault will notice that the page exists in the aux_page_table
and so it will try to page the page in. In order to do this Q will have
to acquire the pin_lock. So, Q will block until P releases the pin_lock.
Thus, the access is prevented until P has evicted the frame. After
P has evicted the frame and releases the pin lock Q is able to 
fault the page back in.


>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

We acquire a pin lock on the frame before we start the process of
filling it. We also acquire a pin lock on the frame before we start
evicting it. Thus, the frame will have a page fully resident in it
before eviction is allowed to occur (and vice versa.)


>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

We have modified our code for verifying addresses in syscalls.
Before we changed it it was responsible for making sure that all
addresses were inside of mapped pages. Now it is responsible for
paging_in_and_pin'ing any page that is referenced. If it fails to
page_in_and_pin a page then it means that the address is invalid.
In this case, we attempt to grow the stack but if this fails
then we kill the process.

(By pinning pages that are accessed through user syscalls, they 
cannot be paged out during the execution of the syscall. After it
completes, we unpin all involved pages.)

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

We have one global lock for each of the frame, swap and aux page 
tables. We  make sure to hold the locks whenever we're doing 
modifications to the structure of the tables (adding new entries, 
deleting entries, or scanning for free ones).

We have a finer grained lock for each frame, as well. Whenever we want
to do work on a frame's data, or on a page that is contained in a frame,
we acquire the frame's lock. This allows a high degree of concurrency in
IO; every time a process tries to page in its data into a frame, it can
block on I/O and let other processes continue. (Processes can page_in
from disk or swap concurrently.)

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Inside of thread.h's struct thread:

struct list mmap_descriptors;       /* List of mmaps opened by thread. */

`mmap_descriptors` is a list of all of the mmap descriptors that were
  opened by this process.

In page.c's `struct aux_pt_entry`:

struct
  {
    size_t offset;    /* How far into the file we are */
    size_t len;       /* How much of the file to read */
    struct file *fd;  /* Which file we're reading from */
  } mmap_info;

Used by an aux_pt_entry to keep track of its MMAP information.
 The three fields together completely define the backing store 
 for the page.

In syscall.c:

struct mmap_descriptor
  {
    int mmap_id;            /* user-id for the mmap */
    void *start;            /* starting user virtual address of mmap */
    off_t pages;            /* number of mmaped pages */
    struct file *file;      /* file; reopened by us, need to close */
    struct list_elem elem;  /* elem in threads mmap_descriptor list */
  };

This struct is stored in a list per-thread. 

`mmap_id` is returned to the user. Used to look-up the struct when
  referenced later.

The rest is explained in the adjacent comments.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

On page fault (so page-in) or eviction (page-out), an mmapped page is
read in from (or written to) its appropriate backend file instead of
being paged in from disk. This behavior is controlled by an 
aux_pt_entry's `type' (of MMAP or SWAP).

On page-in, we always read in a pages content back from the file
(zeroing the tail, as required). On page-out, however, we only write
a page's data if the page is writable and dirty.

We use the same API to trigger page_in and page_outs for mmap'd pages.
All that changes is the API for creating them. There is a page_create--
mmap_page that takes in all of the information necessary. Aside from
that, the internal API is identical. The page_out code knows enough
to treat the MMAP eviction as just another strategy.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

When mapping a file, we simply attempt to loop through the file and 
allocate sufficient pages for all of the file's data. Before actually
creating a new page for the mmap we check to see if there is already
an entry in the auxiliary page table for the page corresponding to that
virtual address (rounded down) and, if so, we recognize the overlap. 
(Freeing any pages we have already made for the mmap and failing out.)

Thus, an mmap should fail in this way if and only if there was already
some segment (or other mmap, etc) mapped to that space of virtual
memory.


---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

We shared code almost completely through these two use-cases. The
creation of pages that are demand-paged to disk is exposed through
a single function in page.h, `page_create_mmap_page', which also takes
in a `swapped' bool. A swapped==false corresponds to a standard mmap
that is written out to disk when dirty, while swapped==true means
that the page is actually demand-paged back out to swap (as in the
data of an executable).

We also require files used in such mappings to be closed externally
as well, as the executable is maintained by a process and any user
mmapped file is managed in syscall.c. 

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
