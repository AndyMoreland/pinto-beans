        +---------------------------+
		    | CS 140                    |
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	DESIGN DOCUMENT           |
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Alex Ryan <alexryan@stanford.edu>
Andy Moreland <andymo@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

Alex Ryan: 
Andy Moreland: 

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

The MMU uses the standard pagedir/page table system that was in place 
when we started writing code. We make sure to keep these tables up
to date as we create pages.

On the other hand, if we need to find the location of a frame for a
given page we do the following:

1) get the user vaddr of an address in the page
2) look up a aux_page_table_entry in a hash table in page.c
3) this entry contains an ID for (actually, an internal pointer to)
a frame_table_entry from frame.c 
4) the frame_table_entry contains a kernel address for the page's data.

A page retains the ID of its last resident frame if it has been paged
out; if it has been paged out, the frame can discern that it now 
contains the data for a different page.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We sidestep the issue by never touching memory through kernel addresses.
In theory the only time that user data should get dirty is if the user
themself touches it or uses a syscall. All of our syscalls directly
use user addresses.

Thus, the user page table entry is the only one that we need to check
for accessed and dirty bits.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

Before we do any operation on the frame table (eviction, creating new
frames, freeing a frame), we acquire a global lock.

palloc_get_page locks internally. Thus, if there are free frames in
the user pool, we're safe.

If there is nothing in the user pool, we check the free list next.
We make sure to acquire the frame table lock before iterating over the
free list, so there are no race conditions here.

On the other hand, if we need to perform an eviction we make sure
to acquire a lock on the frame table. This lock is held until
we find a frame which we're going to evict a page from.

Thus, in any situation where we need to acquire a page we hold a 
global lock until a slot is selected.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We chose to use a hash table from vaddrs to aux_ptes in order
to have O(1) lookup on a vaddr. This makes sense to do because the 
page fault handler only gets the vaddr when it's called, so we can't
do something like store a pointer directly to a struct.

Then, the aux_pte struct contains a direct reference to its frame or
eviction locations so looking up the actual physical address/file 
in which it lives is O(1).

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Used by the swap.c implementation to denote a contiguous sequence
 * of sectors that have been used for swap. */
typedef block_sector_t swap_descriptor;

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We use a clock hand algorithm. We maintain a global "hand" pointer
which points to a frame_table_entry. The frame_table_entries
are stored in a list which we then iterate over while holding
a lock on the frame table.

At each entry we attempt to acquire a "pin" lock on the entry itself.
If we are able to acquire then pin lock then we know that no one else
is currently touching it. In this case, we check its accessed bit.
If it has not been accessed, we drop evict this frame and drop the
global lock. Otherwise, we clear its accessed bit and continue on.

(We loop at most twice through the entire frame table, so we could end
up evicting a frame that has been accessed recently. However, after
two attempts, if we still cannot pin anything, then everything is
pinned and we are unable to evict anything, and panic.)

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

We have designed our code so that if we acquire a pin_lock on the frame
that we think we're resident in then we immediately check if we are 
actually still resident before doing any work. If we are resident,
then we own the frame. Otherwise, we've been paged out in the interim
and we immediately drop the lock.

This means that we don't need to have frames change their page's refs
to null. Instead, all that we do is ask the page to evict itself.

As part of this eviction, the page stores where it evicted itself to.
This can be a file or swap slot.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

We check to see if the fault was caused by a user access. Then we check
the aux page table in order to make sure that there isn't supposed to be
memory mapped at that location.

Then, we check that the fault was either within 32 bytes of the esp or
that it was above the esp. If either of these conditions are true we
check to make sure that increasing the size of the stack further would
not exceed a maximum stack size of 8mb. If all of these conditions are
met then we grow the stack.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

The four conditions for deadlock are all of (1) limited access,
(2) no preemption, (3) multiple independent requests, and (4)
circularity in resources ownership requests. As in most systems,
the first three are unavoidable in our implementation, so we
chose to treat and prevent (4).

Our virtual memory implementation uses locks to prevent most of
the interesting concurrency problems: these locks are the
- fs_lock (file system)
- "data structure locks" (aux_page_table, frame_table, swap_used_slots)
- frame_pins (one for each frame)

All virtual memory calls acquire locks in the order
  (frame_table lock) 
    before (frame pins) 
    before (fs_lock | swap_used_slots lock)

(A corner case is when a frame is first created, in that it acquires 
the frame_table_lock before even creating the frame, but since the 
new frame isn't in the table, the lock cannot be held by another 
process yet.)

Furthermore, a process can pin as many of its *own* pages' frames
as it wants (and since we're single-threaded processes, cannot create
a race condition). However, a process can hold at most one of another
process's frames but _only when trying to evict it_ and is accomplished
through a try_acquire, avoiding any race conditions (it is impossible
for a process to be stuck waiting on another process's frame).

Finally, aux_page_table operations are all done either independently 
of any frame operations (i.e. when pages are first created, but have
not been given a resident frame) or while a page's own frame's pin
is held (so processes always acquire frame pins before aux_pt_lock).


>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

Whenever a process P evicts another process Q's frame what we do is
acquire the pin lock on that frame and then immediately mark it as
not present in the page table.

Once these operations have been completed we start the eviction. If
an access from Q occurs at this point it will result in a page fault.
The page fault will notice that the page exists in the aux_page_table
and so it will try to page the page in. In order to do this Q will have
to acquire the pin_lock. So, Q will block until P releases the pin_lock.
Thus, the access is prevented until P has evicted the frame. After
P has evicted the frame and releases the pin lock Q is able to 
fault the page back in.


>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

We acquire a pin lock on the frame before we start the process of
filling it. We also acquire a pin lock on the frame before we start
evicting it. Thus, the frame will have a page fully resident in it
before eviction is allowed to occur (and vice versa.)


>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

We have modified our code for verifying addresses in syscalls.
Before we changed it it was responsible for making sure that all
addresses were inside of mapped pages. Now it is responsible for
paging_in_and_pin'ing any page that is referenced. If it fails to
page_in_and_pin a page then it means that the address is invalid.
In this case, we attempt to grow the stack but if we choose not to
then we kill the process.

(By pinning pages that are accessed through user syscalls, they 
cannot be paged out during the execution of the syscall. After it
completes, we unpin all involved pages.)

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

We have one global lock for each of the frame, swap and aux page 
tables. We  make sure to hold the locks whenever we're doing 
modifications to the structure of the tables (adding new entries, 
deleting entries, or scanning for free ones).

We have a finer grained lock for each frame, as well. Whenever we want
to do work on a frame's data, or on a page that is contained in a frame,
we acquire the frame's lock. This allows a high degree of concurrency in
IO; every time a process tries to page in its data into a frame, it can
block on I/O and let other processes continue. (Processes can page_in
from disk or swap concurrently.)

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Used by an aux_pt_entry to keep track of its MMAP information.
 * The three fields together completely define the backing store 
 * for the page. */
struct
  {
    size_t offset;    /* How far into the file we are */
    size_t len;       /* How much of the file to read */
    struct file *fd;  /* Which file we're reading from */
  } mmap_info;

/* Used by syscall.c to keep track of user mmaps; stored as a list
 * in the thread. */
struct mmap_descriptor
  {
    int mmap_id;            /* user-id for the mmap */
    void *start;            /* starting virtual address of mmap */
    off_t pages;            /* number of mmaped pages */
    struct file *file;      /* file; reopened by us, need to close */
    struct list_elem elem;  /* elem in threads mmap_descriptor list */
  };

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

On page fault (so page-in) or eviction (page-out), an mmapped page is
read in from (or written to) its appropriate backend file instead of
being paged in from disk. This behavior is controlled by an 
aux_pt_entry's `type' (of MMAP or SWAP).

On page-in, we always read in a pages content back from the file
(zeroing the tail, as required). On page-out, however, we only write
a page's data if the page is writable and dirty.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

When mapping a file, we simply attempt to loop through the file and 
allocate sufficient pages for all of the file's data. Before actually
creating a new page for the mmap we check to see if there is already
an entry in the auxiliary page table for that virtual address and,
if so, we recognize the overlap. (Freeing any pages we have already
made for the mmap and failing out.)

Thus, an mmap should fail in this way if and only if there was already
some segment (or other mmap, etc) mapped to that space of virtual
memory.


---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

We shared code almost completely through these two use-cases. The
creation of pages that are demand-paged to disk is exposed through
a single function in page.h, `page_create_mmap_page', which also takes
in a `swapped' bool. A swapped==false corresponds to a standard mmap
that is written out to disk when dirty, while swapped==true means
that the page is actually demand-paged back out to swap (as in the
data of an executable).

We also require files used in such mappings to be closed externally
as well, as the executable is maintained by a process and any user
mmapped file is managed in syscall.c. 

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
